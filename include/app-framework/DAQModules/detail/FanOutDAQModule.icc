
template<typename DATA_TYPE>
appframework::FanOutDAQModule<DATA_TYPE>::FanOutDAQModule(
  std::string name,
  std::vector<std::shared_ptr<QueueI>> inputs,
  std::vector<std::shared_ptr<QueueI>> outputs)
  : DAQModule(name, inputs, outputs)
  , mode_(FanOutMode::NotConfigured)
  , bufferTimeout_(100)
  , thread_(std::bind(&FanOutDAQModule<DATA_TYPE>::do_work, this))
{
  if (inputs.size() > 1) {
    throw std::runtime_error("Invalid Configuration for "
                             "FanOutDAQModule: More than one Input "
                             "provided!");
  }

  inputQueue_.reset(dynamic_cast<QueueOutput<DATA_TYPE>*>(&*inputs_[0]));

  for (auto& output : outputs) {
    outputQueues_.push_back(std::shared_ptr<QueueInput<DATA_TYPE>>(
      dynamic_cast<QueueInput<DATA_TYPE>*>(&*output)));
  }
}

template<typename DATA_TYPE>
std::future<std::string>
appframework::FanOutDAQModule<DATA_TYPE>::execute_command(std::string cmd)
{
  if (cmd == "configure" || cmd == "Configure") {
    return std::async(std::launch::async, [&] { return do_configure(); });
  }
  if (cmd == "start" || cmd == "Start") {
    return std::async(std::launch::async, [&] { return do_start(); });
  }
  if (cmd == "stop" || cmd == "Stop") {
    return std::async(std::launch::async, [&] { return do_stop(); });
  }

  return std::async(std::launch::async,
                    [] { return std::string("Unrecognized Command"); });
}

template<typename DATA_TYPE>
std::string
appframework::FanOutDAQModule<DATA_TYPE>::do_configure()
{
  // TODO: Get configuration from ConfigurationManager!
  mode_ = FanOutMode::RoundRobin;
  wait_interval_us_ = 1000000;

  return "Success";
}

template<typename DATA_TYPE>
std::string
appframework::FanOutDAQModule<DATA_TYPE>::do_start()
{
  thread_.start_working_thread_();
  return "Success";
}

template<typename DATA_TYPE>
std::string
appframework::FanOutDAQModule<DATA_TYPE>::do_stop()
{
  thread_.stop_working_thread_();
  return "Success";
}

template<typename DATA_TYPE>
void
appframework::FanOutDAQModule<DATA_TYPE>::do_work()
{
  auto roundRobinNext = outputQueues_.begin();

  while (thread_.thread_running()) {
    if (!inputQueue_->empty()) {
      auto data = inputQueue_->pop(bufferTimeout_);

      if (mode_ == FanOutMode::Broadcast) {
        do_broadcast(data);
      } else if (mode_ == FanOutMode::FirstAvailable) {
        auto sent = false;
        while (!sent) {
          for (auto& o : outputQueues_) {
            if (!o->full()) {
              o->push(std::move(data), bufferTimeout_);
              sent = true;
              break;
            }
          }
          if (!sent) {
            usleep(wait_interval_us_);
          }
        }
      } else if (mode_ == FanOutMode::RoundRobin) {
        while (true) {
          if (!(*roundRobinNext)->full()) {
            (*roundRobinNext)->push(std::move(data), bufferTimeout_);

            if (++roundRobinNext == outputQueues_.end())
              roundRobinNext = outputQueues_.begin();
            break;
          } else {
            usleep(wait_interval_us_);
          }
        }
      }
    } else {
      usleep(wait_interval_us_);
    }
  }
}