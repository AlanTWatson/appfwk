
template <class T, class U> DequeBuffer<T, U>::DequeBuffer() { Configure(); }

template <class T, class U> void DequeBuffer<T, U>::Configure() {

  this->fAttributes.isBounded = true;
  this->fAttributes.isSearchable = false;

  fDeque = std::deque<value_type>();
  fSize = 0;

  if (this->fAttributes.isBounded) {
    fCapacity = 1000;
  } else {
    fCapacity = fDeque.max_size();
  }
}

template <class T, class U>
void DequeBuffer<T, U>::push_wait_for(value_type &&object_to_push,
                                      const duration_type &timeout) {

  auto starttime = std::chrono::steady_clock::now();
  std::unique_lock<std::mutex> lk(fMutex, std::defer_lock);

  lk.try_lock();

  if (!lk.owns_lock() && timeout.count() > 0) {

    int approximate_number_of_retries = 5;
    duration_type pause_between_tries =
        duration_type(timeout.count() / approximate_number_of_retries);

    while (std::chrono::steady_clock::now() < starttime + timeout) {
      std::this_thread::sleep_for(pause_between_tries);
      lk.try_lock();
      if (lk.owns_lock()) {
        break;
      }
    }
  }

  if (!lk.owns_lock()) {
    std::ostringstream errmsg;
    errmsg << "In DequeBuffer::push_wait_for: unable to lock the buffer's "
              "mutex within the timeout period of "
           << std::chrono::duration_cast<std::chrono::milliseconds>(timeout)
                  .count()
           << " milliseconds";
    throw std::runtime_error(errmsg.str());
  }

  auto time_to_wait_for_space =
      (starttime + timeout) - std::chrono::steady_clock::now();
  time_to_wait_for_space = time_to_wait_for_space.count() > 0
                               ? time_to_wait_for_space
                               : duration_type(0);

  fNoLongerFull.wait_for(lk, time_to_wait_for_space,
                         [&]() { return !this->full(); });

  if (!this->full()) {
    fDeque.push_back(std::move(object_to_push));
    fSize++;
    fNoLongerEmpty.notify_one();
  } else {
    std::stringstream errmsg;
    errmsg
        << "In DequeBuffer::push_wait_for: unable to push since queue is full ("
        << this->size() << " elements) (timeout period was "
        << std::chrono::duration_cast<std::chrono::milliseconds>(timeout)
               .count()
        << " milliseconds)";
    throw std::runtime_error(errmsg.str());
  }
}

template <class T, class U>
T DequeBuffer<T, U>::pop_wait_for(const duration_type &timeout) {

  auto starttime = std::chrono::steady_clock::now();
  std::unique_lock<std::mutex> lk(fMutex, std::defer_lock);

  lk.try_lock();

  if (!lk.owns_lock() && timeout.count() > 0) {

    int approximate_number_of_retries = 5;
    duration_type pause_between_tries =
        duration_type(timeout.count() / approximate_number_of_retries);

    while (std::chrono::steady_clock::now() < starttime + timeout) {
      std::this_thread::sleep_for(pause_between_tries);
      lk.try_lock();
      if (lk.owns_lock()) {
        break;
      }
    }
  }

  if (!lk.owns_lock()) {
    std::ostringstream errmsg;
    errmsg << "In DequeBuffer::pop_wait_for: unable to lock the buffer's mutex "
              "within the timeout period of "
           << std::chrono::duration_cast<std::chrono::milliseconds>(timeout)
                  .count()
           << " milliseconds";
    throw std::runtime_error(errmsg.str());
  }

  auto time_to_wait_for_data =
      (starttime + timeout) - std::chrono::steady_clock::now();
  time_to_wait_for_data = time_to_wait_for_data.count() > 0
                              ? time_to_wait_for_data
                              : duration_type(0);

  fNoLongerEmpty.wait_for(lk, time_to_wait_for_data,
                          [&]() { return !this->empty(); });

  if (!this->empty()) {
    T obj(std::move(fDeque.front()));
    fDeque.pop_front();
    fSize--;
    fNoLongerFull.notify_one();
    return obj;
  } else {
    std::stringstream errmsg;
    errmsg << "In DequeBuffer::pop_wait_for: unable to pop since queue is "
              "empty (timeout period was "
           << std::chrono::duration_cast<std::chrono::milliseconds>(timeout)
                  .count()
           << " milliseconds)";
    throw std::runtime_error(errmsg.str());
  }
}
